# 첨언: 스프링 시큐리티에서 제공하는 기능 쓰면 되긴 함

# 순서
1. 회원가입
- 입력과 검증(중복)

2. 로그인
- 일반 로그인 / 자동 로그인
- 세션, 쿠키

3. 인증, 인가 처리
- 인증: 회원임을 명시(로그인 여부)
- 인가: 회원의 접근 구역(권한 확인)
 + ex) 일반 회원, 유료 회원, VIP 회원

4. API
-----------------------------------------------------------

# 1. 회원 테이블 만들기
``` sql
-- 회원 관리 테이블
CREATE TABLE tbl_member (
    account VARCHAR2(50),   -- 계정명
    password VARCHAR2(150) NOT NULL,
        -- 비밀번호 : DB에 암호화해서 저장해야 하기 때문에 바이트가 큼(평문으로 저장하면 안 됨)
        -- 사이트 관리자가 회원의 비밀번호 원본을 볼 수 없어야 함
    name VARCHAR2(50) NOT NULL,     -- 이름
    email VARCHAR2(100) NOT NULL UNIQUE,
        -- 최근 추세는 이메일과 어카운트를 통일하는 것
        -- JMS를 쓰면 이메일 인증할 수 있음
    auth VARCHAR2(20) DEFAULT 'COMMON',
        -- 권한: common  / admin
    reg_date DATE DEFAULT SYSDATE,
    -- 추가로 필요한 컬럼
        -- 로그인 이력 테이블 (필수사항)
        -- 마지막 로그인 시간(?)
    CONSTRAINT pk_member PRIMARY KEY (account)
);

SELECT * FROM tbl_member;
```

# MemberMapper 인터페이스
- 패키지 : com.project.web_prj.member.repository

- Map과 class 어느 걸 선택해야 할까?

``` Map : 필드가 적을 때 쓰면 좋음
// 중복 체크 기능
        // 체크타입: 계정 or 이메일
        // 체크값: 중복검사대상 값
  int isDuplicate(Map<String, Object> checkMap);
```
``` class : 필드가 많아지면 클래스 따로 빼서 상속으로
public class DuplicationCheck{
    private String type;
    private String value;
}
```

# 회원 비밀번호 관리
- 암호 원문 그대로 DB에 저장하면 안 됨
- 관리자 누구도 볼 수 없다고 함
- BCryptPasswordEncoder를 빈 등록하면 매번 객체 생성 안 해도 됨
``` build.gradle
//스프링 시큐리티 라이브러리
   implementation 'org.springframework.boot:spring-boot-starter-security'
   implementation 'org.springframework.security:spring-security-test'
```
``` 비밀번호 인코딩하기
        // 인코딩 전 비밀번호
        String rawPassword = "ddd5555";

        // 인코딩을 위한 객체 생성
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

        // 인코딩 후 비밀번호
        String encodePassword = encoder.encode(rawPassword);

        System.out.println("rawPassword = " + rawPassword);
        System.out.println("encodePassword = " + encodePassword);
```
```
        m.setPassword(new BCryptPasswordEncoder().encode("1234"));
```

# 회원 중복체크
``` 동적 SQL, Map을 보낸다고 하면 key를 type에, value를 value로
   <!-- 중복체크 기능 (아이디, 이메일)   -->
    <select id="isDuplicate" resultType="int">

        SELECT COUNT(*)
        FROM tbl_member
        <if test="type=='account'">
            WHERE account = #{value}
        </if>
        <if test="type=='email'">
            WHERE email = #{value}
        </if>

    </select>
```
``` MemberService
    // 중복확인 중간처리

    /**
     * 계정과 이메일의 중복을 확인하는 메서드
     * @param type - 확인할 정보 (ex: account or email)
     * @param value - 확인할 값
     * @return 중복이라면 true, 중복이 아니라면 false
     */
    public boolean checkSignUpValue(String type, String value) {
        Map<String, Object> checkMap = new HashMap<>();
        checkMap.put("type", type);
        checkMap.put("value", value);

        return memberMapper.isDuplicate(checkMap) == 1;
    }
```

# mapper Test
- 실패 등 여러 테스트 할 것


# 스프링 시큐리티
- 시큐리티 제공 로그인 화면이 기본값으로 들어가있음
+ ID : user / password: 매번 바뀜
## 시큐리티 설정하기
+ package com.project.web_prj.config
+ SecurityConfig 클래스 만들기
+ @Configuration @EnableWebSecurity //시큐리티 설정을 웹에 적용
### 기본 제공 로그인 화면 없애기
```  시큐리티 기본 설정을 처리하는 빈
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        // 초기에 나오는 디폴트 로그인 화면 안뜨게 하기
        http.csrf().disable()
                .authorizeRequests()
                .antMatchers("/member/**")
                .permitAll();

        return http.build();
    }
```

# 회원가입
## 1. 회원가입 폼 : sign-up.jsp
> form action="/member/sign-up" name="signup" id="signUpForm" method="post"
- method="post"
- auth는 hidden으로도 안 넘기는 게 좋음(프론트에서 바꿀 수 있으니까)
 + 회원은 무조건 common으로 등록하고
 + admin은 나중에 관리자가 부여할 수 있도록 한다(update)
 + 
## 2. 회원 가입 폼 띄우기 (MemberController)
``` 요청 URL과 포워딩 경로가 완벽히 똑같을 때는 void로 해도 됨
    @GetMapping("/sign-up")
    public void signUp() {
        log.info("/member/sign-up GET!!");
//        return "member/sign-up";
    }
```

## 3. 회원 가입